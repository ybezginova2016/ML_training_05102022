import numpy as np

a = np.array([
    [-7, 8],
    [2, 31]
])
b = np.linalg.inv(a)

print("Матрица:")
print(a)
print("Обратная матрица:")
print(b)
print("Проверка единичной матрицей:")
print((a @ b).round())

print()

import numpy as np

a = np.array([
    [9, -7, 15],
    [6, 3, 29],
    [0, 3, 7]
])
b = np.linalg.inv(a)
print("Матрица:")
print(a)
print("Обратная матрица:")
print(b)
print("Проверка единичной матрицей:")
print(((a @ b).round()))

"""
Вместо единичной матрицы получилось что-то странное, но мы всё 
объясним.
Дело в том, что все десятичные дроби код выводит в экспоненциальном 
виде. Это представление числа в виде произведения мантиссы, 
то есть числа не меньше 11 и не больше 1010, и экспоненты — 
степени десятки, которая отделяется от мантиссы буквой e.
И 3.55271368e-15 — это 3.5527136\cdot10^{-15}=0.00000000000000355271363.5527136⋅10 
−15
 =0.0000000000000035527136, что при округлении даст 0.0.
На самом деле, даже значение 3.55271368e-15 — уже результат округления бесконечной дроби, который может не совпадать в разных версиях программы. Так что на этом этапе могут получиться совсем другие числа. Чтобы проверка давала на выходе единичную матрицу в привычном формате, будем округлять результат до ближайшего целого. Для этого нужна функция .round().

В коде получился отрицательный ноль, и это совершенно нормально. 
Дело в том, что Python относится к нулю как к любому другому 
числу со своим значением и знаком. В итоге могут происходить 
операции, в которых значение результата окажется 0, а знак -:
"""

print(np.array(0) / -2)
# >> -0.0 # вывод

"""
Различие между -0.0 и 0.0 сделано умышленно, но имеет достаточно 
специфичные применения — ноль со знаком может использоваться 
для представления бесконечно малых величин, в приложениях 
математического анализа.
"""
print()
import numpy as np

a = np.array([
    [0.55, 0.4, 1.2, 6],
    [-12, -9, 0.5, 1],
    [8.8, -8, -4, 2.9],
    [1.3, 7, -0.94, 2]
])
b = np.linalg.inv(a)

print("Матрица:")
print(a)
print("Обратная матрица:")
print(b)
print("Проверка единичной матрицей:")
print(((a @ b).round()))

print()

import numpy as np

a = np.array([
    [3, -9, 12],
     [6, 18, 24],
     [1, 11, 7]
])
b = np.linalg.inv(a)

print("Матрица:")
print(a)
print("Обратная матрица:")
print(b)
print("Проверка единичной матрицей:")
print(((a @ b).round()))

"""
Текстовые задачи в коде

Обратные матрицы применяют не только для геометрических 
преобразований векторов. Матричная форма также может заменить 
решение уравнений в классических алгебраических задачах.
"""

##### TASK 3 #####

# Человеческий билет на электричку стоил 325325 рублей, а собачий —
# 8181. Обратно ехали на автобусе: 260260 рублей с человека и
# 6060 с пса. На путь за город вся компания потратила
# 25992599 рублей, обратно — 20602060 рублей. Сколько всего
# людей и зверей ездили на корпоратив собачников?
print()
import numpy as np

a = np.array([
    [325, 81],
    [260, 60]
])
b = np.array([2599, 2060])
o = np.linalg.inv(a) # Вычисление обратной матрицы

b_column = b.reshape(2, 1) # из вертикального вектора сделали горизонтальный
result = o @ b_column # Скалярное произведение

print(result)

# [[7.]
#  [4.]]
# В компании было 77 человек и 44 пёсика!

##### TASK 4 #####

# Перед поездкой Макс купил 22 пачки сосисок для гриля, 2.82.8 кг
# кабачков и 3 бутылки воды. В электричке выяснилось, что идея
# купить продукты пришла не только ему.

# Бухгалтер тётя Нина купила 1 пачку сосисок, 5 кг кабачков
# и 2 бутылки воды.

# Маркетолог Андрюша кабачки не купил, но взял
# с собой 4 пачки сосисок и 4 бутылки воды.

# Все трое были в одном магазине и купили продукты
# одних и тех же марок.
# Макс потратил 794794 рубля,
# тётя Нина — 740740 рублей,
# Андрюша — 920920 рублей.

# Напишите программу для вычисления цен пачки сосисок,
# килограмма кабачков и бутылки воды. Вектор затрат сохраните
# в переменной b, а результат вычислений — в переменной result.
print()
import numpy as np

a = np.array([
    [2, 2.8, 3],
    [1, 5, 2],
    [4, 0, 4]
])
b = np.array([794, 740, 920])
o = np.linalg.inv(a) # Вычисление обратной матрицы

b_column = b.reshape(3, 1) # из вертикального вектора сделали горизонтальный
result = o @ b_column # Скалярное произведение

print(result)

# Ценыы на пачку сосисок, кг кабачков и бутылки воды
# [[120.]
#  [ 80.]
#  [110.]]