# При матричном умножении (англ. matrix multiplication) по двум
# матрицам строится третья. Она состоит из скалярных произведений
# строк первой матрицы на столбцы второй. Так результатом произведения
# i-й строки матрицы A (Ai) на j-й столбец матрицы B (Bj) станет
# элемент матрицы С c индексами i, j (Cij):
# В NumPy матрицы A и B умножаются вызовом функций np.dot(A, B),
# или A.dot(B). Также этот вызов можно заменить знаком матричного
# умножения @.

import numpy as np

A = np.array([
    [1, 2, 3],
    [-1, -2, -3]])

B = np.array([
    [1, 0],
    [0, 1],
    [1, 1]])

print(A.dot(B))
print(np.dot(A, B))
print(A @ B)

# Результат умножения матриц зависит от порядка множителей.
# Перемножим матрицы A и B в другом порядке:

print(B @ A)
# Если ширина первой матрицы не равна длине второй, то умножение
# невозможно.
matrix = np.array([
    [1, 2, 3],
    [-1, -2, -3]])

# NOT POSSIBLE
# print(matrix @ matrix)
# Произошла ошибка: размерности матриц не согласованы (англ. mismatch).
# Умножение матрицы на себя возможно, только если она квадратная:

square_matrix = np.array([
    [1, 2, 3],
    [-1, -2, -3],
    [0, 0, 0]])

print(square_matrix @ square_matrix)

##### TASK 1 #####

# 1. Вернёмся к мобильному оператору «Шмеляйн». В вашем распоряжении
# матрица, которая содержит данные о составе пакетов клиентов за месяц.
# Рассчитайте количество минут, СМС и мегабайтов, которые потратили
# все клиенты за месяц. Выведите результат в матрице clients_services,
# у которой строки соответствуют клиентам, а столбцы — сервисам.

# Количество минут разговора, СМС и мегабайты, которые потратил
# один клиент, — произведение матрицы packs на вектор пакетов
# этого клиента. Но в таблице clients_packs векторы расположены
# по строкам, а не по столбцам. Значит, эту матрицу нужно
# транспонировать.

import numpy as np
import pandas as pd

services = ['Минуты', 'СМС', 'Мбайты']
packs = np.array([
    [20, 5],
    [2, 5],
    [500, 1000]])

packs_names = ['«За рулём»', '«В метро»']
clients_packs = np.array([
    [1, 2],
    [2, 3],
    [4, 1],
    [2, 3],
    [5, 0]])

print('Пакеты')
print(pd.DataFrame(clients_packs, columns=packs_names))
print()

clients_services = np.dot(clients_packs, packs.T)

print('Минуты, СМС и Мбайты')
print(pd.DataFrame(clients_services, columns=services))
print()

# Kогда работаешь с произведением матриц, очень удобно пользоваться
# следующим свойством: матрицу А с размерностью (N, M) можно
# умножить на матрицу B с размерность (K, P) тогда и только тогда, когда M = K.
# Это правило помогает понять, в каком порядке
# нужно записать матрицы в произведении

###### TASK 2 ######

# 2. Данные сохранили в двух матрицах:
# manufacture — расход материалов на разную мебель;
# furniture — набор мебели в каждом заведении.

# Шаг 1 - Посчитайте, сколько материалов уходит на каждое
# заведение. Результат сохраните в матрице venues_material.
# Тогда функция print() выведет его на экран.

# Шаг 2 - Посчитайте расход материалов, если заказы поступили
# от 18 кофеен, 12 бистро и 7 ресторанов. Эти данные мы
# записали в переменной venues (англ. «заведения»).
# Результат сохраните в переменной total_materials.
# Тогда функция print() выведет его на экран.

import numpy  as np
import pandas as pd

materials_names = ['Древесная плита', 'Металлическая труба', 'Винты']
# матрица, где по строкам указана мебель, а по столбцам — материалы для её изготовления
manufacture = np.array([
    [0.2, 1.2, 8],
    [0.5, 0.8, 6],
    [0.8, 1.6, 8]])

venues_names = ['Кофейня', 'Бистро', 'Ресторан']
# матрица, где по строкам указаны заведения, а по столбцам — виды мебели
furniture = np.array([
    [12, 0, 3],
    [40, 2, 10],
    [60, 6, 18]])

venues_materials = np.dot(furniture, manufacture)

print('По заведениям')
print(pd.DataFrame(venues_materials, index=venues_names, columns=materials_names))
print()

venues = np.array([18, 12, 7])

# vector venues (1, 3) and venues_materials matrix (3, 3)
total_materials = np.dot(venues, venues_materials)

print('Всего')
print(pd.DataFrame([total_materials], index=[''], columns=materials_names))